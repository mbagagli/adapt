import logging
import numpy as np
from obspy import UTCDateTime
from itertools import combinations
#
import adapt.errors as QE
import adapt.database as QD

logger = logging.getLogger(__name__)

"""ADAPT weight module.

In this module are stored all the classes and functions to define the
uncertainty estimation of a certain phase arrival time, based on the
ensemble measurements. In this module are stored also the methods
To identify the erroneous pick observation.

Note:
    Scientists typically make repeated measurements of a quantity to
    ensure the quality of their findings and to know both the precision
    and the accuracy of their results.
    Measurements are said to be precise if they yield very similar
    results when repeated in the same manner. A measurement is
    considered accurate if it yields a result that is very close to
    the true or accepted value.
    Precise values agree with each other; accurate values agree with a
    true value. These characterizations can be extended to other
    contexts, such as the results of an archery competition.

"""


# timing_method="median",
# uncertainty_estimator="std"):
class Weighter(object):
    def __init__(self,
                 pickdict,
                 analysis_key=(),
                 wintest_thr=0.3,
                 interphase_thr=0.6):

        """ This class orchestrate the weighting of a multipicking stage

        This class will store all the statistical information about the
        multipicking stage for giving a weight by means of classical
        statistical information.

        Args:
            pickdict (dictionary): derived from PickContainer class
                with the picked multipicking stage.
            analysiskey (list,tuple): iteretable containing the last
                field (after split by '_') of the phase picktag at the
                given station. Alternatively it could be also the full
                phase picktag as well. The _setup function will take
                care of creating a proper dictionary for the query.
            timing_method (str): define the pick-time extraction
                ['median','mean']
            uncertainty_estimator (str): define the pick-error estimation
                method ['std', 'var', 'weight_std', 'mad', 'aad']

        Attributes:
            pd (adapt.database.PickContainer): pick container
                with the picked multipicking stage.
            sk (str): station key entry for the given pick dict.
            pk (list,tuple): iteretable containing the last
                field (after split by '_') of the phase picktag at the
                given station. Alternatively it could be also the full
                phase picktag as well. The _setup function will take care of
                creating a proper dictionary for the query.
            wd (dict): working dict generated by the provate class
                method  _setup.
            pick_method = timing_method
            error_method = uncertainty_estimator

        Note:
            The key in the LeaveOneOut (loo) dict refers to the pick
            that has been removed prior recalculating the statistical
            method.

            This class is HARDCODED to work with only 2 window for each
            picker algorithms.

            REMEMBER TO RUN MANUALLY THE TRIAGE METHOD !!
        """

        # MB: `analysis_key` are the initial multipicking tag / full tag
        if not isinstance(pickdict, dict):
            logger.error("Input data must be a dict!")
            raise QE.InvalidType()

        # Unwrap input parameters
        self.pd = pickdict
        self.pk = analysis_key
        self.win_thr = wintest_thr
        self.phase_thr = interphase_thr
        # Additional attributes
        self.pickers_names = []    # MB handled by _setup method
        self.wd = {}               # MB handled by _setup method

        # MB next dict is handled by the self.triage method
        self.triage_dict = {'tot_obs': 0,
                            'valid_obs': [],
                            'spare_obs': [],
                            'stable_pickers': [],
                            'failed_pickers': [],
                            'outliers': [],
                            'pickers_involved': []}
        self.triage_results = {'mean': None,
                               'median': None,
                               'mean-median': None,
                               'std': None,
                               'var': None,
                               'mad': None,
                               'aad': None,
                               'mmd': None,
                               # Bootstrap method
                               'bootmode': None,
                               'bootmean': None,
                               'bootmadmode': None}

        self.bootobj = None  # Bootstrap object for final decision

        # Initial setup
        self._setup()

    # ========================================== Private Method
    # ==========================================

    def _setup(self):
        """ Created to reformat the input PickDict into something
            more handy for the class
            wd = {''}
        """
        # MB:
        # Should create the `self.wd` with all the keys being
        # floats {'BK_one':float(UTCDateTime)}

        for _kk in self.pd.keys():
            if (_kk.split('_')[-1] in self.pk) or (_kk in self.pk):
                pickername = _kk.split('_')[0]
                self.pickers_names.append(pickername)
                # We are in the list containing picks from picker
                for _idx, _pick in enumerate(self.pd[_kk]):
                    if _pick['timeUTC_pick']:
                        self.wd[pickername + '_' + str(_idx+1)] = (
                                        float(_pick['timeUTC_pick']))
                    # added in 0.6.14
                    else:
                        self.triage_dict["failed_pickers"].append(
                                                pickername + '_' + str(_idx+1))
        #
        if not self.wd:
            logger.warning("Creation of a working dict failed! " +
                           "Try using different pick-keys ... ")
            logger.warning("Analysis Key: %s" % self.pk)

    def _calc_inter_related_pickers_delta(self):
        """ This method will calculate all the possible combination
            of deltas from picker in the first and second slices
        """
        # @develop: at the moment, BAIT is ignored from pairs.
        #           If needed to be implemented, make sure to use the
        #           the right BAIT pick associated to the MP stage
        #           you're working on.
        pairs = list(combinations(self.pickers_names, 2))
        pairs = [_comb for _comb in pairs if 'BAIT' not in _comb]

        for _xx in ('1', '2'):
            for _cc in pairs:
                _store_key = '_'.join([_cc[0], _cc[1], _xx])
                try:
                    _store_val = (self.wd[_cc[0]+'_'+_xx] -
                                  self.wd[_cc[1]+'_'+_xx])
                except KeyError:
                    _store_val = None
                #
                self.triage_dict[_store_key] = _store_val

    def _define_pickers_involved(self):
        """ This method defines which family of pickers picked
            AT LEAST one observation present in the VALIDOBS

            i.e:
               valid_obs = [('FP_2', 1474838059.984538),
                            ('BK_2', 1474838059.979538)]
        """
        tpl = [_ll[0].split("_")[0] for _ll in self.triage_dict["valid_obs"]]
        self.triage_dict["pickers_involved"] = sorted(set(tpl))

    def _convert_functions_output(self, val, out_type="date"):
        """ Simply return the UTCDateTime conversion of floats, or the
            float istself if otherwise specified.
        """
        if out_type.lower() == "date":
            return UTCDateTime(val)
        elif out_type.lower() == "float":
            try:
                return np.float(val)
            except ValueError:
                raise QE.InvalidParameter("Input VAL must be numeric")
        else:
            raise QE.InvalidParameter("OUT_TYPE parameter must be one of"
                                      "['date', 'float']")

    # ============ Calculate

    def _calc_mean(self, inlist):
        """ Calculate the mean float of INLIST picks.

            Note:
                The INLIST variable must contain floats only
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.mean(inlist)
        else:
            raise QE.InvalidType()

    def _calc_median(self, inlist):
        """ Calculate the MEDIAN float of INLIST picks

            Note:
                The INLIST variable must contain floats only
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.median(inlist)
        else:
            raise QE.InvalidType()

    def _calc_mode(self, inlist):
        """ Calculate the MODE VALUE float of INLIST picks

            Note:
                The INLIST variable must contain floats only
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            values, counts = np.unique(inlist, return_counts=True)
            m = counts.argmax()
            return values[m], counts[m]
        else:
            raise QE.InvalidType()

    def _simple_minmax_delta(self, inlist):
        """ Calculate the DIFFERENCE between the maxima and minima
            INLIST picks

            Note:
                The INLIST variable must contain floats only!
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.max(inlist) - np.min(inlist)
        else:
            raise QE.InvalidType()

    def _simple_std(self, inlist):
        """ Calculate the STANDARD DEVIATION float of INLIST picks

            Note:
                The INLIST variable must contain floats only
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.std(inlist)
        else:
            raise QE.InvalidType()

    def _simple_var(self, inlist):
        """ Calculate the VARIANCE float of INLIST picks

            Note:
                The INLIST variable must contain floats only
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.var(inlist)
        else:
            raise QE.InvalidType()

    def _simple_mad(self, inlist):
        """Median Absolute Deviation"""
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.median(np.abs(inlist - np.median(inlist)))
        else:
            raise QE.InvalidType()

    def _simple_aad(self, inlist):
        """Average Absolute Deviation"""
        if isinstance(inlist, (list, tuple, np.ndarray)):
            return np.mean(np.abs(inlist - np.mean(inlist)))
        else:
            raise QE.InvalidType()

    # def _nmad(x):
    #     """Normalized Median Absolute Deviation"""
    #     return mad(x)/scipy.stats.norm.ppf(3/4.) # ~mad(x)/0.6745

    # def naad(x):
    #     Normalized Average Absolute Deviation
    #     return aad(x)/sqrt(2/pi) # approximately aad(x)/0.79788

    # ============ Extract

    def _get_mean(self, iterobj, out_type="date"):
        """ Return the mean float UTCDateTime of all picks in self.wd

            `type` can be "date"  -> return UTCDateTime
                       or "float" -> return float object of seconds
        """
        val = self._calc_mean(iterobj)
        outv = self._convert_functions_output(val, out_type=out_type)
        return outv

    def _get_median(self, iterobj, out_type="date"):
        """ Return the median float UTCDateTime of all picks in self.wd

            `type` can be "date"  -> return UTCDateTime
                       or "float" -> return float object of seconds
        """
        val = self._calc_median(iterobj)
        outv = self._convert_functions_output(val, out_type=out_type)
        return outv

    def _get_mode(self, iterobj, out_type="date"):
        """ Return the mode float UTCDateTime of all picks in self.wd

            `type` can be "date"  -> return UTCDateTime
                       or "float" -> return float object of seconds

            If NO MODE VALUE --> all count ==1:
                The function returns the first VALUE of the array

        """
        val, cnt = self._calc_mode(iterobj)
        outv = self._convert_functions_output(val, out_type=out_type)
        return outv

    def _get_mode_altered(self, iterobj, out_type="date"):
        """ Return the mode float UTCDateTime of all picks in self.wd

            `type` can be "date"  -> return UTCDateTime
                       or "float" -> return float object of seconds

            If NO MODE VALUE --> all count ==1:
                The function will return the median instead ...
                In some cases, it would be useless to have the first
                arrival only.

        """
        val, cnt = self._calc_mode(iterobj)
        if cnt == 1:
            val = self._calc_median(iterobj)
        outv = self._convert_functions_output(val, out_type=out_type)
        return outv

    def _go_bootstrap_me(self, iterobj, n_samples):
        """ This method provides the BOOTSTRAP method for `ns_amples`.
            Return the BOOTSTRAP object
        """
        bs = Bootstrap(iterobj)
        bs.work(n_samples)
        return bs

    def _get_minmax_delta(self, iterobj):
        """ Return the standard deviation in seconds of all the picks

        """
        return self._simple_minmax_delta(iterobj)

    def _get_std(self, iterobj):
        """ Return the standard deviation in seconds of all the picks

        """
        return self._simple_std(iterobj)

    def _get_var(self, iterobj):
        """ Return the variance in seconds of all the picks

        """
        return self._simple_var(iterobj)

    def _get_mad(self, iterobj):
        """ Return the Median Absolute Deviation in seconds
            of all the given pick-obs

        """
        return self._simple_mad(iterobj)

    def _get_aad(self, iterobj):
        """ Return the Average Absolute Deviation in seconds
            of all the given pick-obs

        """
        return self._simple_aad(iterobj)

    def _reject_obs(self):
        """ This method does everythin needed to reject the pick """
        # MB: populate the resulting dict with a bunch of None
        #     because it's already initialized with None(s), just
        #     log the info
        self.triage_results = {}
        logger.info("Pick detection FAILED")

    def _accept_obs(self, iterobj):
        """ This method will take care of store and provide the final
            pick and estimate the error.
            iterobj must be a list or a tuple to proceed further with
            calculation.
        """
        # MB: calculate al the necessary to proceed further
        #       * median
        #       * mean
        #       * median - mean
        #       * std
        #       * var
        #       * mad
        #       * aad
        logger.info("Pick detection PASSED")
        # v0.7.7: for consistency due to numpy lib (i.e. mean)
        iterobj = tuple(sorted(iterobj))  # iterobj is a tuple

        # ------- Populate results: TIMEs
        self.triage_results['mean'] = self._get_mean(iterobj)
        self.triage_results['median'] = self._get_median(iterobj)
        self.triage_results['mode'] = self._get_mode(iterobj)
        self.triage_results['modealt'] = self._get_mode_altered(iterobj)
        self.triage_results['mean-median'] = (
            self.triage_results['mean'] - self.triage_results['median']
            )
        # Populate results: UNCERTAINTIES
        self.triage_results['std'] = self._get_std(iterobj)
        self.triage_results['var'] = self._get_var(iterobj)
        self.triage_results['mad'] = self._get_mad(iterobj)
        self.triage_results['aad'] = self._get_aad(iterobj)
        self.triage_results['mmd'] = self._get_minmax_delta(iterobj)  # minmaxdelta

        # ------- Populate results: BOOTSTRAPs
        # v0.7.10: BootStrap implemented for calculation
        logger.info("Bootstrapping ...")
        self.bootobj = self._go_bootstrap_me(iterobj, 100)
        bval = self.bootobj.extract_statistics(replicastat="median", statproc="mode")
        self.triage_results['bootmode'] = self._convert_functions_output(bval)
        bval = self.bootobj.extract_statistics(replicastat="median", statproc="mean")
        self.triage_results['bootmean'] = self._convert_functions_output(bval)
        bval = self.bootobj.extract_statistics(replicastat="mad", statproc="mode")
        self.triage_results['bootmadmode'] = self._convert_functions_output(
                                                bval, out_type="FLOAT")

    # ========================================== Public Method
    # ==========================================

    def set_analysis_keys(self, inlst):
        """ Setter method to specify the pick-keys to extract and
            analyze. This function will run automatically the private
            `_setup method` and modify the
        """
        if not isinstance(inlst, (tuple, list)):
            raise QE.InvalidType()
        #
        self.pk = inlst
        self.wd = {}     # Reset the old one, avoiding to leave traces
        self._setup()

    def get_working_dict(self):
        """ Return the dictionary used to calculate mean/median,
            std/variance. It is also the starting point for the creation
            of the leave one out dict.
        """
        if self.wd:
            return self.wd
        else:
            logger.error("Missing working_dict!")
            raise QE.MissingAttribute()

    def get_triage_dict(self):
        """ Return the dictionary used to calculate the VALID OBS
        """
        if self.triage_dict:
            return self.triage_dict

    def get_triage_results(self):
        """ Return the dictionary used to calculate the VALID OBS
        """
        if self.triage_results:
            return self.triage_results

    def get_uncertainty(self, method="std"):
        """ Return the pick uncertainty.
            `method` can be "loo"    -> return the leaveoneout dict
                         or "std"    -> return the overall std

            # NB: The key in the loo dict refers to the PICK that has been
                  removed prior recalculating the std !!!

        """
        if self.triage_results:
            if method.lower() in ("std", "all", "ensemble"):
                return self.triage_results['std']
            elif method.lower() in ("var", "variance"):
                return self.triage_results['var']
            elif method.lower() in ("mad", "median absolute deviation"):
                return self.triage_results['mad']
            elif method.lower() in ("aad", "average absolute deviation"):
                return self.triage_results['aad']
            elif method.lower() in ("bootmadmode", "bootmad", "btmd"
                                    "bootstrap mad mode"):
                return self.triage_results['bootmadmode']
            else:
                logger.error("The uncertainty_estimator specified is not valid")
                raise QE.InvalidParameter()
        else:
            logger.warning("Results DICT missing!")
            return None

    def get_picktime(self, method="median"):
        """
        Return the pick uncertainty.
        `method` can be "loo"    -> return the leaveoneout dict
                     or "all"    -> return the overall std
                     or "clean"  -> return the std cleaned from outliers

        # NB: The key in the loo dict refers to the PICK that has been
              removed prior recalculating the std !!!

        """
        if self.triage_results:
            if method.lower() in ("median", "med"):
                return UTCDateTime(self.triage_results['median'])
            elif method.lower() in ("mean", "mea"):
                return UTCDateTime(self.triage_results['mean'])
            else:
                logger.error("The timing_method specified is not valid")
                raise QE.InvalidVariable()
        else:
            logger.warning("Results DICT missing!")
            return None

    def get_bootstrap_obj(self):
        """ Return the Bootstrap class object used for the pick timing
            and uncertainty.
        """
        if self.bootobj:
            return self.bootobj
        else:
            logger.warning("BootStrap OBJ missing!")
            return None

    def triage(self):
        """ Method developed with EK 08102019:
            In here we take care of the phase analysis and pick time
            definition.

            First we define ALL the valid observation (BULK),
            then we feed these on the private self._accept_pick method

            Before finishing this method call the class `_reject_obs()`
            method to clean the observation in case of failure.

            NB: This method MUST work only with the clas working dict
                ONLY!!!
        """
        if not self.wd:
            # MB 01072020: if arrived here, means self.pd is empty!
            #              from v0.7.3 we don't raise error anymore,
            #              but continue with rejection and returning
            #              a False BOOL.
            logger.error("Missing working dict! Run self._setup first!")
            self._reject_obs()
            return False

        # 0) Store the total number of possible information
        self.triage_dict['tot_obs'] = len(self.wd)
        if self.triage_dict['tot_obs'] < 3:
            # We cannot stand with less than 3 observation
            self._reject_obs()
            return False

        # =========================================== DEFINE BULK OBS
        # MB: Basically in this step we ignore any non stable picker
        #     and accept single window picker pick if it falls in
        #     a predefined threshold. This BULK observation will then
        #     be analyzed.
        #

        # 1) WINDOW TEST --> short list picker
        for _pp in self.pickers_names:
            try:
                _deltap = np.abs(self.wd[_pp+"_2"] - self.wd[_pp+"_1"])
                if _deltap < self.win_thr:
                    # === WindowTest PASSED
                    # Store on the stable picker list a tuple with:
                    #   * picker tag
                    #   * absolute float (seconds) of the middle point
                    #   * absolute distance among the 2 win (seconds)
                    self.triage_dict['stable_pickers'].append(
                                            (_pp,
                                             (self.wd[_pp+"_1"] + _deltap/2.0),
                                             _deltap)
                                            )
                    # Store the STABLE PICKER as VALID PICKS
                    self.triage_dict['valid_obs'].append((_pp+"_1", self.wd[_pp+"_1"]))
                    self.triage_dict['valid_obs'].append((_pp+"_2", self.wd[_pp+"_2"]))
                else:
                    # WindowTest FAILED --> Don't take in consideration
                    #                       any picks from this PICKER
                    #                       to evaluate the BULK OBS
                    continue

            except KeyError as misskey:
                # WindowTest NOT POSSIBLE
                # The picker _pp is missing one of the 2 windows
                # Check if the single pick falls inside the confidence
                # interval of the windowtest, if yes take it, else
                # append it to the outliers check list
                win = list(misskey.args[0])[-1]
                if win == '1':
                    _tmp_key = _pp + "_2"
                elif win == '2':
                    _tmp_key = _pp + "_1"
                else:
                    logger.error("Multipicking MAX WINDOW allowed is 2 (for now)")
                    raise QE.InvalidVariable()
                #
                try:
                    self.triage_dict['spare_obs'].append((_tmp_key,
                                                          self.wd[_tmp_key]))
                except KeyError:
                    # Totally missing PICK from work_dict, analyze next picker
                    continue

        # 2) Analyze SPARE observation (could still be valid obs)
        #    compared to the mean of ALL the stable pickers
        #
        #   We must have at least 2 valid pick (1 stable picker) and a
        #   spare lecture to continue

        # Make sure we have at least a STABLE picker to go further
        if not self.triage_dict['valid_obs']:
            self._reject_obs()
            return False

        # If aI have some spare_observation let's see if they could be
        # useful to the BULK obs, otherwise no need to asses further our
        # BULK observation.

        if self.triage_dict['spare_obs']:
            _mean_stable_pick = self._get_mean(
                            [ii[1] for ii in self.triage_dict['valid_obs']])
            for _pk in self.triage_dict['spare_obs']:
                if np.abs(_mean_stable_pick - _pk[1]) <= self.win_thr:
                    # The pick is passed to the valid ones
                    self.triage_dict['valid_obs'].append(_pk)

        ######################################################################
        # -> From here, our 'VALID_OBS' key is our component of BULK obs. <- #
        ######################################################################

        # ... but if I have at this point less than 3 valid picks,
        #     dumps out and no VALID pick is found.
        if len(self.triage_dict['valid_obs']) < 3:
            self._reject_obs()
            return False

        # =========================================== OUTLIERS DETECT
        # MB: Basically in this step we use our bulk observation to
        #     extract information over the possible outliers.
        #
        #
        bulk_tag = [ii[0] for ii in self.triage_dict['valid_obs']]
        bulk_times = [ii[1] for ii in self.triage_dict['valid_obs']]
        bulk_mean = np.mean(bulk_times)

        # From here on, we are collecting also possible additional obs
        # taken from the unalyzed array.
        for _tag, _pk in self.wd.items():
            if _tag not in bulk_tag:
                if np.abs(bulk_mean - _pk) <= self.phase_thr:
                    self.triage_dict['valid_obs'].append((_tag, _pk))
                else:
                    # It's a complete outliers
                    self.triage_dict['outliers'].append((_tag, _pk))

        ######################################################################
        # -> From here, our 'VALID_OBS' key is our group of POSSIBLE obs. <- #
        ######################################################################

        # Collect and go home ...
        final_valid_obs = dict(self.triage_dict['valid_obs'])
        self._accept_obs(tuple(final_valid_obs.values()))

        # MB: 24-10-2019: added this relation for the regression problem
        self._calc_inter_related_pickers_delta()

        # MB: 25-03-2020: added this step to extract picker family
        self._define_pickers_involved()

        return True

    def triage_jk(self):
        """ Method developed in July2020:
            In here we take care of the phase analysis and pick time
            definition.

            Instead of the simple TRIAGE method, this one will use
            a Jack Knife approach to define the outlier among the
            Multipicker observation pool.

            Once the valid obs are found, then we feed these to the
            private self._accept_pick method

            Before finishing this method call the class `_reject_obs()`
            method to clean the observation in case of failure.

            NB: This method MUST work only with the clas working dict
                ONLY!!!

            @develop
            NB: This triage DO NOT return 'stable_pickers', 'spare_obs',
                'failed_pickrs' keys, because spare obs are not
                accounted in this method An observation is either good
                (valid) or an outlier
        """
        if not self.wd:
            # MB 01072020: if arrived here, means self.pd is empty!
            #              from v0.7.3 we don't raise error anymore,
            #              but continue with rejection and returning
            #              a False BOOL.
            logger.error("Missing working dict! Run self._setup first!")
            self._reject_obs()
            return False

        # 0) Store the total number of possible information
        self.triage_dict['tot_obs'] = len(self.wd)
        if self.triage_dict['tot_obs'] < 3:
            # We cannot stand with less than 3 observation
            self._reject_obs()
            return False

        # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ ADAPT wannabe
        # ###################
        # # Collect BULKOBS #
        # ###################
        # # https://www.sciencedirect.com/science/article/pii/B9780080448947013385
        # replicates = {}
        # orig_mean = np.mean(tuple(self.wd.values()))
        # # kk is the LEFT OUT obs
        # for kk, vv in self.wd.items():
        #     # td = {i: self.wd[i] for i in self.wd.keys() if i != kk}
        #     ta = [self.wd[i] for i in self.wd.keys() if i != kk]
        #     replicates[kk] = {'mean': np.mean(ta),
        #                       'bias': np.mean(ta) - orig_mean
        #                       }
        # # Standard deviation of residuals (BIAS)
        # jkn_bias_std = np.std([vv['bias'] for kk, vv in replicates.items()])
        # jkn_bias_mean = np.mean([vv['bias'] for kk, vv in replicates.items()])

        # # v0.8.0 --> filtering by 3 std for the biases with the mean!
        # jkn_bias_low = jkn_bias_mean - 3*jkn_bias_std
        # jkn_bias_high = jkn_bias_mean + 3*jkn_bias_std

        # for kk, vv in replicates.items():
        #     if vv['bias'] >= jkn_bias_low and vv['bias'] <= jkn_bias_high:
        #         self.triage_dict['valid_obs'].append((kk, self.wd[kk]))
        #     else:
        #         # It's a complete outliers
        #         self.triage_dict['outliers'].append((kk, self.wd[kk]))

        # @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ QUAKE-ORIGINAL
        ###################
        # Collect BULKOBS #
        ###################
        # https://www.sciencedirect.com/science/article/pii/B9780080448947013385
        replicates = {}
        orig_mean = np.mean(tuple(self.wd.values()))
        # kk is the LEFT OUT obs
        for kk, vv in self.wd.items():
            # td = {i: self.wd[i] for i in self.wd.keys() if i != kk}
            ta = [self.wd[i] for i in self.wd.keys() if i != kk]
            replicates[kk] = {'mean': np.mean(ta),
                              'bias': np.mean(ta) - orig_mean
                              }
        #
        jkn_bias_std = np.std([np.abs(vv['bias']) for kk, vv in replicates.items()])

        for kk, vv in replicates.items():
            if not np.abs(vv['bias']) >= 3*jkn_bias_std:
                self.triage_dict['valid_obs'].append((kk, self.wd[kk]))
            else:
                # It's a complete outliers
                self.triage_dict['outliers'].append((kk, self.wd[kk]))

        ######################################################################
        # -> From here, our 'VALID_OBS' key is our group of POSSIBLE obs. <- #
        ######################################################################

        if len(self.triage_dict['valid_obs']) >= 4:

            # Collect and go home ...
            final_valid_obs = dict(self.triage_dict['valid_obs'])
            self._accept_obs(tuple(final_valid_obs.values()))

            # MB: 24-10-2019: added this relation for the regression problem
            self._calc_inter_related_pickers_delta()

            # MB: 25-03-2020: added this step to extract picker family
            self._define_pickers_involved()

            return True

        else:
            # Just Go Home...
            self._reject_obs()
            return False


class Bootstrap(object):
    """ This class contains all the necessary tools for bootstrapping
        over a set of observations.

        NOTES:
            In repeated bootstraps:
                37% samples will not have the outlier, 67 will.
    """

    def __init__(self, darr, random_seed=42):
        if not isinstance(darr, np.ndarray):
            self.data = np.array(darr)
        else:
            self.data = darr
        #
        self.rndmseed = random_seed
        self.samples = np.array([])
        self.replicates = np.array([])
        self.rs = np.random.RandomState(self.rndmseed)

    def _reset_state(self):
        """Reset class instance random state

        Note:
            For reproductibility, use this method for new calculations
            since any new calculation will be affected by previous
            stages.
        """
        self.samples = np.array([])
        self.replicates = np.array([])
        self.rs = np.random.RandomState(self.rndmseed)
        return True

    def _calc_mode(self, inlist):
        """ Calculate the MODE VALUE float of INLIST picks

            Note:
                The INLIST variable must contain floats only
        """
        if isinstance(inlist, (list, tuple, np.ndarray)):
            values, counts = np.unique(inlist, return_counts=True)
            m = counts.argmax()
            return values[m], counts[m]
        else:
            raise QE.InvalidType("Input must be an ITERABLE")

    def _resample_with_replacement(self, sizearr, howmany):
        """ Create subset of resampled data """
        self.samples = np.ndarray([howmany, sizearr])

        for _ii in range(0, np.size(self.samples, 0)):
            self.samples[_ii] = self.rs.choice(self.data,
                                               size=sizearr,
                                               replace=True)

    def _create_replicates(self):
        """ Create statistics over new samples """
        nsamples = np.size(self.samples, 0)
        self.replicates = np.ndarray([nsamples, 7])
        for _ii in range(0, nsamples):
            # MEAN
            self.replicates[_ii, 0] = np.mean(self.samples[_ii])
            # MEDIAN
            self.replicates[_ii, 1] = np.median(self.samples[_ii])
            # STD
            self.replicates[_ii, 2] = np.std(self.samples[_ii])
            # MAD
            self.replicates[_ii, 3] = np.median(np.abs(
                                                 self.samples[_ii] -
                                                 np.median(self.samples[_ii])))
            # AAD
            self.replicates[_ii, 4] = np.mean(
                    np.abs(self.samples[_ii] - np.mean(self.samples[_ii])))
            # MIN
            self.replicates[_ii, 5] = np.min(self.samples[_ii])
            # MAX
            self.replicates[_ii, 6] = np.max(self.samples[_ii])

    def work(self, n_resamples=50):
        """ Main function that controls bootstrapping """
        if self.samples.size != 0 or self.replicates.size != 0:
            self._reset_state()
        #
        logger.debug("Working with %d re-sampling data" % n_resamples)
        self._resample_with_replacement(self.data.size, n_resamples)
        self._create_replicates()  # Create statistics over samples

    def get_samples(self):
        """ return the samples array """
        if self.samples.size != 0:
            return self.samples

    def get_replicates(self):
        """ return the replicates statistical array """
        if self.replicates.size != 0:
            return self.replicates

    def get_input_data(self):
        """ Simply return the input data, as a numpy array """
        return self.data

    def extract_statistics(self, replicastat="median", statproc="median"):
        """ This method extract the wanted statiustics from the
            replicates array

            `replicastat` means the statistical properties of each replica
            `statproc` means the processingfor the replicastat values.

            Slot [0] : mean
            Slot [1] : median
            Slot [2] : std
            Slot [3] : mad
            Slot [4] : aad
            Slot [5] : min
            Slot [6] : max

            It will be returned the `statproc`

        """
        if self.replicates.size == 0:
            raise QE.MissingAttribute("Missing REPLICATES arrays, abort!")

        # Extract values
        if replicastat.lower() in ("mean", "mn"):
            statattr = self.replicates[:, 0]
        elif replicastat.lower() in ("median", "med"):
            statattr = self.replicates[:, 1]
        elif replicastat.lower() in ("standarddeviation", "std"):
            statattr = self.replicates[:, 2]
        elif replicastat.lower() in ("mad",):
            statattr = self.replicates[:, 3]
        elif replicastat.lower() in ("aad",):
            statattr = self.replicates[:, 4]
        #
        elif replicastat.lower() in ("min", "minimum"):
            statattr = self.replicates[:, 5]
        elif replicastat.lower() in ("max", "maximum"):
            statattr = self.replicates[:, 6]
        else:
            raise QE.InvalidParameter("'replicastat' parameter can only be "
                                      "['median', 'mean', 'mad', "
                                      "'aad', 'min', 'max']")
        # Process values
        if statproc.lower() in ("mean", "mn"):
            return np.mean(statattr)
        elif statproc.lower() in ("median", "med"):
            return np.median(statattr)
        elif statproc.lower() in ("mode", "frequency"):
            mv, _ = self._calc_mode(statattr)
            return mv
        else:
            raise QE.InvalidParameter("'replicastat' parameter can only be "
                                      "['median', 'mean', 'mode']")


# =================================================
# =================================================
#               TIPS and OLD FUNCTIONS
# =================================================
# =================================================

    # def _triage(self):
    #     """ Method developed with EK 08102019:
    #         In here we take care of the phase analysis and pick time
    #         definition.

    #         NB: This method MUST work only with the clas working dict
    #             ONLY!!!
    #     """
    #     import pprint

    #     if not self.wd:
    #         logger.error("Missing working dict! Run self._setup first!")
    #         raise QE.MissingVariable

    #     # 0) Store the total number of possible information
    #     self.triage_dict['tot_obs'] = len(self.wd)
    #     if self.triage_dict['tot_obs'] < 3:
    #         # We cannot stand with less than 3 observation
    #         self._reject_obs()
    #         # return True

    #     # 1) Short list picker
    #     for _pp in self.pickers_names:
    #         try:
    #             _deltap = np.abs(self.wd[_pp+"_2"] - self.wd[_pp+"_1"])
    #             if _deltap < self.win_thr:
    #                 # Store on the stable picker list a tuple with:
    #                 #   * picker tag
    #                 #   * absolute float (seconds) of the middle point
    #                 #   * absolute distance among the 2 win (seconds)
    #                 self.triage_dict['stable_pickers'].append(
    #                                         (_pp,
    #                                          (self.wd[_pp+"_1"] + _deltap/2.0),
    #                                          _deltap)
    #                                         )
    #                 self.triage_dict['valid_obs'].append(self.wd[_pp+"_1"])
    #                 self.triage_dict['valid_obs'].append(self.wd[_pp+"_2"])
    #             else:
    #                 # The picker alg. picked twice, but not stable
    #                 self.triage_dict['to_analyze_obs'].append(
    #                                                         self.wd[_pp+"_1"])
    #                 self.triage_dict['to_analyze_obs'].append(
    #                                                         self.wd[_pp+"_2"])
    #         except KeyError:
    #             # One window missing:
    #             try:
    #                 self.triage_dict['to_analyze_obs'].append(
    #                                                         self.wd[_pp+"_1"])
    #             except KeyError:
    #                 pass

    #             try:
    #                 self.triage_dict['to_analyze_obs'].append(
    #                                                         self.wd[_pp+"_2"])
    #             except KeyError:
    #                 pass

    #             # Analyze next picker
    #             continue

    #     print(self.triage_dict['to_analyze_obs'])

    #     # 2) Switch on STABLE PICKERS:
    #     if self.triage_dict['stable_pickers']:

    #         # 2a) we only RELY on one picker
    #         if len(self.triage_dict['stable_pickers']) == 1:

    #             # 2a.1) check if other obs fall nearby the STABLE picker
    #             for _p in self.triage_dict['to_analyze_obs']:
    #                 if (np.abs(self.triage_dict['stable_pickers'][0][1] - _p)
    #                    <= self.win_thr):
    #                     self.triage_dict['valid_obs'].append(_p)

    #             # 2a.2) If we have at least 3 valid obs we store it!
    #             if len(self.triage_dict['valid_obs']) >= 3:
    #                 print('accetto')
    #                 self._accept_obs()
    #                 # return True
    #             else:
    #                 print('rigetto')
    #                 self._reject_obs()
    #                 # return True

    #         else:
    #             # 2b) we RELY on more than one picker
    #             #     * at this point, the only valid_picks are the one
    #             #       obtained ONLY by the STABLE PICKERS
    #             _tmpmean = self._get_mean(self.triage_dict['valid_obs'],
    #                                       out_type="float")

    #             # 2b.1) Analyze the other obs base on a STABLE mean
    #             for _p in self.triage_dict['to_analyze_obs']:
    #                 if np.abs(_tmpmean - _p) <= self.interphase_thr:
    #                     self.triage_dict['valid_obs'].append(_p)

    #             # 2b.2) Store the final statistics of the VALID OBS
    #             self._accept_obs()

    #     else:
    #         # No stable picker and therefore missing stuff
    #         self._reject_obs()
    #         # return True

    #     pprint.pprint(self.wd)
    #     pprint.pprint(self.triage_dict)
